package scalaxy; package components

import scala.tools.nsc.plugins.PluginComponent
import scala.tools.nsc.ast.TreeDSL
import scala.tools.nsc.transform.TypingTransformers
import Function.tupled

trait Replacements
extends TypingTransformers
   with MirrorConversions
{
  this: PluginComponent =>

  //import global._
  import global.definitions._
  import scala.tools.nsc.symtab.Flags._

  //import scala.reflect._
  
  //import scala.reflect.api._
  //import scala.reflect.runtime._
  //import scala.reflect.runtime.Mirror._
  //import scala.reflect.mirror._
  
  type Bindings = (Map[global.TermName, global.Tree], Map[global.Type, global.Type])
  val EmptyBindings: Option[Bindings] = Some(Map(), Map())
  
  def matchAndResolveBindingsList(reps: List[(mirror.Tree, global.Tree)], depth: Int = 0)(implicit internalDefs: InternalDefs): Option[Bindings] = {
    import Function._
    val maps: List[Option[Bindings]] = reps.map(p => {
      val (aaa, bbb) = p
      matchAndResolveBindings(aaa, bbb, depth)
    })
    if (maps.isEmpty)
      None
    else
      maps.reduceLeft((x, y) => (x, y) match {
        case (None, _) => None
        case (_, None) => None
        case (Some((tr1, tp1)), Some((tr2, tp2))) => Some((tr1 ++ tr2, tp1 ++ tp2))
      })
  }
  
  type InternalDefs = Set[mirror.Name]
  
  def getNamesDefinedIn(stats: List[mirror.Tree]): Set[mirror.Name] =
    stats.collect { case mirror.ValDef(_, name, _, _) => name: mirror.Name } toSet
    
  def matchAndResolveBindings(pattern: mirror.Tree, tree: global.Tree, depth: Int = 0)(implicit internalDefs: InternalDefs = Set()): Option[Bindings] = {
    //println("internalDefs = " + internalDefs) 
    //println("matchAndResolveBindings(" + pattern + ", " + tree + ")")
    val ret: Option[Bindings] = (pattern, tree) match {
      case (_, _) if pattern.isEmpty && tree.isEmpty =>
        EmptyBindings
      case 
        //(EmptyTree, EmptyTree) | // BUG !!!
        (mirror.This(_), global.This(_)) =>
        //(_: mirror.TypeTree, _: global.TypeTree) // TODO
        EmptyBindings
      case (_: mirror.TypeTree, _: global.TypeTree) =>
        Some((Map(), Map(pattern.tpe -> tree.tpe)))
        /*
        def pp(o: Any) = {
          if (o == null)
            "?"
          else {
            val c = o.getClass
            c.getName + " <- " + c.getSuperclass.getName
          }
        }
        println("Found type trees " + pp(pattern.tpe) + ", tree of type " + pp(tree.tpe))
        println(pattern)
        println(tree)
        val ptpe = pattern.tpe
        val ttpe = tree.tpe
        
        val tv = mirror.asInstanceOf[scala.reflect.internal.Types].TypeVar
        */
          /*
          case TypeRef(pre, sym @ (NothingClass|AnyClass), _) => copyTypeRef(tycon, pre, sym, Nil)   //@M drop type args to Any/Nothing
      case TypeRef(pre, sym, _)                           => copyTypeRef(tycon, pre, sym, args)
      case PolyType(tparams, restpe)                      => restpe.instantiateTypeParams(tparams, args)
      case ExistentialType(tparams, restpe)               => newExistentialType(tparams, appliedType(restpe, args))
      case st: SingletonType                              => appliedType(st.widen, args) // @M TODO: what to do? see bug1
      case RefinedType(parents, decls)                    => RefinedType(parents map (appliedType(_, args)), decls) // MO to AM: please check
      case TypeBounds(lo, hi)                             => TypeBounds(appliedType(lo, args), appliedType(hi, args))
      case tv@TypeVar(_, _)                               => tv.applyArgs(args)
      case AnnotatedType(annots, underlying, self)        => AnnotatedType(annots, appliedType(underlying, args), self)
      case ErrorType                                      => tycon
      case WildcardType   
          */
      case (mirror.Ident(n), _) =>
        if (internalDefs.contains(n))
          EmptyBindings
        else
          Some((Map(mirrorToGlobal(n) -> tree), Map()))
      case (mirror.ValDef(mods, name, tpt, rhs), global.ValDef(mods2, name2, tpt2, rhs2))
      if mods.modifiers == mods2.modifiers =>
        matchAndResolveBindings(rhs, rhs2, depth + 1)(internalDefs + name)
      
      case (mirror.Function(vparams, body), global.Function(vparams2, body2)) =>
        matchAndResolveBindingsList((body, body2) :: vparams.zip(vparams2), depth + 1)(internalDefs ++ vparams.map(_.name))
        
      case (mirror.TypeApply(fun, args), global.TypeApply(fun2, args2)) =>
        matchAndResolveBindingsList((fun, fun2) :: args.zip(args2), depth + 1)
      
      case (mirror.Apply(a, b), global.Apply(a2, b2)) =>
        matchAndResolveBindingsList((a, a2) :: b.zip(b2), depth + 1)
        
      case (mirror.Block(l, v), global.Block(l2, v2)) =>
        matchAndResolveBindingsList((v, v2) :: l.zip(l2), depth + 1)(internalDefs ++ getNamesDefinedIn(l))
        
      case (mirror.Select(a, n), global.Select(a2, n2)) =>
        if (n.toString == n2.toString)
          matchAndResolveBindings(a, a2, depth + 1)
        else if (n.toString == "apply") {
          a match {
            case mirror.Ident(n) =>
              if (internalDefs.contains(n))
                EmptyBindings
              else
                Some((Map(mirrorToGlobal(n) -> tree), Map()))
            case _ =>
              // TODO check this ?
              EmptyBindings
          }
        } else {
          println("Select name mismatch : " + n + " != " + n2)
          None
        }
      
      //case (ClassDef(mods, name, tparams, impl), ClassDef(mods2, name2, tparams2, impl2)) =
      //  matchAndResolveBindings(impl, impl)(internalDefs + name)
      
      case _ =>
        None
    }
    
    if (depth > 1 && ret == None) {
      println("Matching failed : pattern of type " + Option(pattern).map(_.getClass.getName) + ", tree of type " + Option(tree).map(_.getClass.getName))
      println(pattern)
      println(tree)
    }
    ret
  } 
  
  def replace(replacement: global.Tree, bindings: Map[global.Name, global.Tree]) = {
    new global.Transformer {
      override def transform(tree: global.Tree) = tree match {
        case global.Ident(n) =>
          bindings.get(n).getOrElse(tree)
        case _ =>
          super.transform(tree)
      }
    }.transform(replacement)
  }
}
