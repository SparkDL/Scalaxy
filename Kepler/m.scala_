
import language.implicitConversions
import language.experimental.macros

object Impl {
  import scala.reflect.runtime.currentMirror._
import scala.reflect.runtime.universe._

  def tree(c: Context)(v: c.Expr[Any]): c.Expr[mirror.Tree] = {
    //val imported = {
    //  //val importer = new mirror.Importer { val from = c.mirror }
    //  importer.importTree({
    //    v.tree.asInstanceOf[importer.from.Tree]
    //  })
    //}
    import c.mirror._
    
    val t = v.tree
    val rt = c.reifyTree(c.reflectMirrorPrefix, v.tree)//c.typeCheck(v.tree))
    
    val mirrorDefFixer = new Transformer {
      override def transform(t: Tree) = t match {
        case Block(ValDef(mods, name, tpt, rhs) :: rest, value) if name == nme.MIRROR_SHORT =>
          implicit def s2t(s: String): Name = newTermName(s)
          val mr = c.typeCheck(Select(Select(Select(Ident("scala"), "reflect"), "package"), "mirror"))
          c.typeCheck(Block(c.typeCheck(ValDef(mods, name, TypeTree(mr.tpe), mr)) :: rest, value))
        case _ =>
          t//super.transform(t)
      }
    }
    var fixedRt = mirrorDefFixer.transform(rt)
    //val rt = c.reify(v.tree)
    //val rt = c.reify(c.reflectMirrorPrefix, t)
    
    //val rt = c.typeCheck(Utils[c.type](c).removeDoubleReify(rt))
    println("t = " + t)
    println("rt = " + rt)
    println("fixedRt = " + fixedRt)
    
    val ret = fixedRt.eval
    println("ret = " + ret)
    
    //val foo: c.Expr[mirror.Tree] = (//c.Expr[c.Expr[mirror.Tree]](
    //  c.reifyTree(
    //    c.reflectMirrorPrefix, 
    //    v.tree.asInstanceOf[c.mirror.Tree]
    //  )
    //  
    //  /*c.typeCheck(
    //    Utils[c.type](c).removeDoubleReify(
    //      Apply(Select(c.prefix.tree, newTermName( name )), List( projection.tree ))
    //     ).asInstanceOf[Tree]
    //    ))*/
    //)
    //val ret = c.reify{ foo.eval }
    
    ret//.eval
    //}
    //c.Expr[mirror.Tree](reify { rt.eval }.tree)
    
    //c.Expr[mirror.Tree](c.reifyTree(c.reflectMirrorPrefix, v.tree))
    //c.Expr[mirror.Tree]({
    //  //(c.reify { v.tree.asInstanceOf[reflect.mirror.Tree] }).tree
    //  (c.reify{(c.reify { v.tree }).eval }.asInstanceOf[reflect.mirror.Tree])
    //})
  }
}
object Macros {
  import scala.reflect.runtime.currentMirror._
import scala.reflect.runtime.universe._

  def tree(v: Any): Tree = macro Impl.tree
}
